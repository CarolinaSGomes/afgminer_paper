Application developers often work on performance-sensitive applications. They measure the performance of such applications in order to detect the fragments of source-code (\eg source-code lines) that take up more execution time than others. The idea is to rewrite fragments or to move fragments in such a way that the resulting compiled code is more efficient. In contrast to compiler developers, however, application developers do not necessarily have the required knowledge to analyze low-level profiles that relate performance measurements to control flow or to hardware behavior, \ie edge, path and hardware-instrumented profiles. As a consequence, application developers typically profile their applications using tools such as \emph{tprof}~\cite{TProf} to collect memory and run-time data that are associated with higher-level program constructs, \eg functions and source-code lines. Although higher-level profiling tools work well for the identification of performance bottlenecks in applications that have discernible hot methods, they do not help developers in the analyses of flat-profile applications. That is because the tools are not able to indicate to developers specific code regions that should be modified to improve performance. Randomly selecting code regions to modify is clearly not a good solution either. A better alternative is to select code regions that have similar functionality in terms of operations, and modify those code regions similar to one another that, in aggregation, take up significant execution time. SCPMiner is able to mine for such code fragments.

In order to aggregate code fragments that have similar functionality, source-code features are used. Examples of features are the number of operations (\eg addition, subtraction), the number of statements involving each data type (be it primitive or user-defined), the type of statement (\eg if-conditional, while-statement, return-statement), among others. The features are collected by parsing the target application's source-code, converting it into an abstract syntax tree (AST) and traversing the AST. When the AST is traversed, basic blocks and the appropriate flow edges are connected to generate CFGs. Simultaneously to the composition of CFGs from the AST, features are collected from the code fragments that generated each basic block. A feature vector is associated with every basic block and each feature is a weighted attribute. Thus we have a set of EFGs in which each node is a basic block with features. Then, hierarchical cluster analysis is performed to group basic blocks with similar feature vectors. After clustering, a single attribute is associated with each of the EFG nodes. This attribute is simply the label associated with the cluster to which the EFG node belongs according to the clustering algorithm. 

AFGMiner is used to mine the dataset of AFGs and find heavyweight \emph{source-code patterns} (SCP). SCPs are sets of cluster labels as described above, connected by flow edges and associated with source-code lines that represent the pattern occurrences. Modifying these code patterns may lead to application performance improvements because the pattern occurrences are known to take up significant execution time when aggregated, and the fact that they have similar functionality makes it easier for developers to understand what should be changed in the code, as well as modify all occurrences at once. 




