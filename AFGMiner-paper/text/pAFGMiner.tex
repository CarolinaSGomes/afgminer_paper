A parallel version of AFGMiner, {\bf p-AFGMiner}, benefits from the multiple cores available in many computing systems. p-AFGMiner initially distributes $A_{0}$ among threads, and as heavyweight patterns are found, local queues of parent patterns $Q_{TL}$ and local sets of attributes $A_{TL}$ are formed by each thread. Once all threads are synchronized, all $Q_{TL}$s are unified into a global queue $Q$, and all $A_{TL}$s into a global $A_{k+1}$ set of attributes. The algorithm starts processing the next generation, if $Q$ is not empty. The dataset of AFGs, $DS$, is read-only during the entire run of p-AFGMiner, allowing the maintenance of thread-local versions of variables and thus reducing synchronization. An important challenge in the implementation of this parallel version is the workload distribution to improve load balancing. The number of occurrences of the parent of a pattern $p$ in $DS$ is the most important factor determining the time required to search for occurrences of $p$. A reasonable heuristic tries to balance the number of parent-pattern occurrences assigned to each thread. 

The pattern-distribution heuristic created for p-AFGMiner sorts the $m$ patterns in $Q$ by decreasing order of the number of parent-pattern occurrences. The heuristic then does a round-robin assignment of patterns to threads following an increasing order for the patterns with an even position in the sorted $Q$ and in decreasing order for patterns with an odd position in the sorted $Q$. This simple $O(n)$ heuristic is effective for a moderate number of threads and for limited variations in the number of parent-pattern occurrences. Experimental evaluation revealed that this workload-distribution heuristic lowered the execution time of p-AFGMiner, on average, by 6\% when compared with a naive workload distribution method that simply distributes patterns among the threads without any sorting.


 


 
