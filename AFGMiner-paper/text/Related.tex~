FlowGSP is a sequential-pattern mining algorithm that finds patterns whose occurrences are sub-paths of AFGs~\cite{JockschCC10, FlowGSP}. AFGMiner differs from FlowGSP in that it is able to find not only sequential patterns, but also patterns whose occurrences are sub-graphs of AFGs. AFGMiner takes less time than FlowGSP to find each pattern. In addition, AFGMiner is able to map each pattern to all its occurrences and output this mapping to the user.

gSpan is a classic sub-graph mining algorithm. The main difference between AFGMiner and gSpan is that AFGMiner is able to handle multiple node attributes and uses breadth-first search with eager pruning when generating candidate patterns, while gSpan follows a depth-first approach~\cite{gSpan}. FFSM is another well-known sub-graph mining algorithm, and its novelty was the introduction of embeddings that make the mining process faster. AFGMiner-locreg also uses embeddings. However in FFSM, an embedding does not take into consideration the edge relations for each occurrence of the sub-graph because mined graphs are undirected. In contrast, AFGMiner has to record the complete mapping between sub-graph patterns and occurrences, which makes the embeddings more memory-consuming. Gaston is a more recent sub-graph mining algorithm. It is based on the fact that substructures typically mined for in datasets, such as sub-paths, sub-trees, and sub-graphs, are contained in each other. This property allows the search to be split into steps of increasing complexity. A frequent path, tree and graph miner are thus integrated into a single algorithm. Gaston follows the breadth-first approach to search, and, similarly to AFGMiner, was implemented with and without embeddings. In contrast to AFGMiner, however, Gaston only mines for patterns in non-attributed, undirected and unweighted graphs~\cite{Gaston}. The work of \emph{Horvart \etal} describes a sub-graph mining algorithm for outerplanar graphs, which are a strict generalization of trees~\cite{HorvathKDD06}. Similarly to AFGMiner the algorithm runs in incremental polynomial time due to the properties of outerplanar graphs, \ie they are similar enough to trees.

The work that inspired the creation of SCPMiner is the code clone detection tool \emph{Deckard} presented by \emph{Jiang \etal}~\cite{Deckard}. The clone detection algorithm created by \emph{Jiang \etal} for Deckard, similarly to SCPMiner, converts the source-code of the program to be analyzed into its AST. The algorithm characterizes sub-trees of the AST as vectors of source-code characteristics that capture structural information about the represented code. It then uses efficient hashing and near-neighbor querying for numerical vectors to cluster such sub-trees into code clones. SCPMiner, analogously, converts the AST into a set of CFGs with source-code characteristics associated with each basic block composing the CFGs, and clusters the blocks as an initial step to find source-code patterns. However, SCPMiner does not use a sophisticated clustering scheme such as Deckard's. Adapting Deckard's clustering scheme to SCPMiner would in all likelihood greatly improve the quality of patterns found by AFGMiner.

A work related to HEPMiner is that of \emph{Dreweke \etal}. It applies sub-graph mining to help compiler developers in their program improvement efforts~\cite{DrewekeCGO07}. The work presents a new approach to an existing code transformation called procedural abstraction. The approach consists of composing data flow graphs from the target program and mining, using gSpan, for frequent sub-graph patterns that represent the code segments to be extracted. HEPMiner differs from this work in that it is not a code transformation, but rather an external performance analysis tool that helps compiler developers to reach conclusions about the performance of applications of interest, and detect improvement opportunities. 
