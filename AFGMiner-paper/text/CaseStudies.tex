The process of optimizing computer systems, compilers, computer architecture and computer applications often involves the analysis of the dynamic behaviour of an application. When this optimization is performed offline it involves the analysis of the runtime profile collected over a single, or many, executions of an application. For many applications it is possible to identify {\em hot-spots} in the application profile that consist of segments of the application's source code that account for a larger portion of the execution time. The effort to improve any part of the computer system that influences the application performance can then easily focus on these hot-spots. However, there is a class of computer applications that have no such hot-spots. Instead, the execution time is distributed over a very large code base, with no method taking up signicant execution time (\ie no more than 2 or 3\%). Such applications are said to have \emph{flat profiles}.

The execution of such applications also generates very large profiles that are difficult to analyze by manual inspection. Thus, the {\bf Profile-based Program Analysis} (PBPA) problem is defined as follows. Given a profile {\em Prof} obtained from an execution of a computer program, automatically discover operation patterns in the execution of {\em Prof} that, in aggregation, account for a sufficiently large fraction of the program's execution time. Developers are then able to focus their optimization efforts on those areas in the program code that correspond to occurrences of the relevant operation patterns. In order to solve PBPA, we convert it to a heavyweight pattern mining problem, by modeling the program as a dataset of attributed flow graphs named \emph{Execution Flow Graphs} (EFGs). The EFG is an attributed flow graph that has nodes, edges, weights and attributes whose semantics vary according to the target user of the program analysis. AFGMiner is then applied to the dataset of EFGs, and heavyweight patterns found are the ones relevant to developers. 

This section discusses the run-time complexity of AFGMiner when mining EFGs. In general, the complexity of AFGMiner depends on the type of attributed flow graph being mined.

The section also presents two practical applications of AFGMiner to PBPA. The first is HEPMiner, a tool that targets compiler and architecture developers and intends to facilitate the analysis of programs that have been profiled by hardware instrumentation\cite{Nagpurkar-caecw07}. 

The second practical application of AFGMiner is SCPMiner, a tool that targets application developers and associates heavyweight patterns with source-code lines that the developer may modify in order to obtain performance improvements.

\subsection{Sub-Graph Mining in Bounded Treewidth Graphs}

A structured program is one that combines sub-programs to compute a function, and does so by using any combination of three fundamental control structures: (i) sequential execution of sub-programs; (ii) selective execution of certain sub-programs instead of others by evaluating boolean variables; and (iii) execution of a sub-program repeatedly until a boolean variable is true. More specifically, a structured program is free of \emph{goto}-clauses. The classic work of \emph{Bohm and Jacopini} shows that any program using \emph{goto} can be converted into a \emph{goto}-free form~\cite{Bohm}. This conversion is done by (\eg C and C++) compilers as part of the transformation from source-code to a compiler-specific and language-agnostic Intermediate Representation (IR). \emph{Thorup} shows that graphs representing the control flow of structured programs (\ie Control Flow Graphs) have tree-width of at most six~\cite{Thorup}. Therefore, CFGs of structured programs have small tree-width, or, more generally, bounded tree-width. 

Tree-width is a measure of how similar to a tree a graph is. It is a very useful property because several NP-hard problems on graphs become tractable for the class of graphs with bounded tree-width, including sub-graph isomorphism detection and, as a consequence, frequent sub-graph mining of connected graphs~\cite{Horvath}. \emph{Horvarth and Ramon} discovered a level-wise sub-graph mining algorithm that lists frequent connected sub-graphs in incremental polynomial time in cases when the tree-width of the graphs being mined is bounded by a constant~\cite{Horvath}. Because CFGs have bounded tree-width, so do the AFGs that represent CFGs, \ie EFGs. In the applications of AFGMiner shown in this paper, AFGMiner runs in incremental polynomial time because the problem being solved is fundamentally the problem of finding frequent connected sub-graphs in a dataset of bounded tree-width flow graphs. The addition of weights in nodes and edges and weighted attributes to nodes does not change the complexity of the algorithm. 

The fact that nodes, edges and attributes are weighted and edges are directed does not interfere in the complexity of the algorithm, but the generation of attribute sets of increasing size when creating new candidate patterns does. However, the number of attributes that an extension node of a $k$-edge candidate pattern with $k > 0$ or that the single node of a 0-edge candidate pattern can have is bounded by the size of $A$, \ie by the number of possible attributes that each pattern node may contain. As a consequence, the attribute-set growth component of the algorithm has a constant complexity, while the sub-graph mining component has incremental polynomial complexity. We can thus say that AFGMiner has incremental polynomial complexity when applied to PBPA.


