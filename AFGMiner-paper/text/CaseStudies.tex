The process of optimizing computer systems, compilers, computer architecture and computer applications often involves the analysis of the dynamic behaviour of an application. When this optimization is performed offline it involves the analysis of the runtime profile collected over a single, or many, executions of an application. For many applications it is possible to identify {\em hot-spots} in the application profile that consist of segments of the application's source code that account for a larger portion of the execution time. The effort to improve any part of the computer system that influences the application performance can then easily focus on these hot-spots. However, there is a class of computer applications that have no such hot-spots. Instead, the execution time is distributed over a very large code base, with no method taking up signicant execution time (\ie no more than 2 or 3\%). Such applications are said to have \emph{flat profiles}.

The execution of such applications also generates very large profiles that are difficult to analyze by manual inspection. Thus, the {\bf Profile-based Program Analysis} (PBPA) problem is defined as follows. Given a profile {\em Prof} obtained from an execution of a computer program, automatically discover operation patterns in the execution of {\em Prof} that, in aggregation, account for a sufficiently large fraction of the program's execution time. Developers are then able to focus their optimization efforts on those areas in the program code that correspond to occurrences of the relevant operation patterns. In order to solve PBPA, we convert it to a heavyweight pattern mining problem, by modeling the program as a dataset of attributed flow graphs named \emph{Execution Flow Graphs} (EFGs). EFGs are control flow graphs with attributes and weights provided by profile information, and represent profiled program methods.

This section discusses the run-time complexity of AFGMiner when mining EFGs. In general, the complexity of AFGMiner depends on the type of attributed flow graph being mined.

The section also presents a practical application of AFGMiner to PBPA. HEPMiner is a tool that targets compiler and architecture developers and intends to facilitate the analysis of programs that have been profiled by hardware instrumentation\cite{Nagpurkar-caecw07}. 

\subsection{Sub-Graph Mining in Bounded Treewidth Graphs}

Tree-width is a measure of how similar to a tree a graph is. It is a very useful property because several NP-hard problems on graphs become tractable for the class of graphs with bounded tree-width, including sub-graph isomorphism detection and, as a consequence, frequent sub-graph mining of connected graphs~\cite{Horvath}. \emph{Horvarth and Ramon} discovered a level-wise sub-graph mining algorithm that lists frequent connected sub-graphs in incremental polynomial time in cases when the tree-width of the graphs being mined is bounded by a constant~\cite{Horvath}. \emph{Thorup} shows that graphs representing the control flow of structured programs (\ie control flow graphs) have tree-width of at most six~\cite{Thorup}. Therefore, CFGs of structured programs have bounded tree-width. 

Because CFGs have bounded tree-width, so do EFGs. In the application of AFGMiner shown in this paper, AFGMiner runs in incremental polynomial time because the problem being solved is fundamentally finding frequent connected sub-graphs in a dataset of EFGs. The addition of weights in nodes and edges and weighted attributes to nodes does not change the complexity of the algorithm, but the generation of attribute sets of increasing size when creating new candidate patterns does. However, the number of attributes that an extension node of a $k$-edge candidate pattern with $k > 0$ or that the single node of a 0-edge candidate pattern can have is bounded by the size of $A$, \ie by the number of possible attributes that each pattern node may contain. As a consequence, the attribute-set growth component of the algorithm has a constant complexity, while the sub-graph mining component has incremental polynomial complexity. We can thus say that AFGMiner has incremental polynomial complexity when applied to PBPA.


