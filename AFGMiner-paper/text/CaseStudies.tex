The  {\bf Profile-based Program Analysis} (PBPA) problem, a common challenge among compiler engineers and computer architects, is defined as follows. Given a profile {\em Prof} obtained from an execution of a computer program, automatically discover operation patterns in the execution of {\em Prof} that, in aggregation, account for a sufficiently large fraction of the program's execution time. If PBPA is properly handled, developers are then able to focus their optimization efforts on those areas in the program code that correspond to occurrences of the relevant operation patterns. In order to solve PBPA, we convert it to a heavyweight pattern mining problem, by modeling the program as a dataset of attributed flow graphs named \emph{Execution Flow Graphs} (EFGs). EFGs are control flow graphs with added attributes (hardware-related events captured by performance counters) and associated weights (CPU cycles spent on instructions and events). Our tool HEPMiner then uses the AFGMiner algorithm to find \emph{heavyweight execution patterns} (HEP): sets of hardware-related events associated with assembly instructions that were executing when the events happened~\cite{GomesMSc12}.

\subsection{Sub-Graph Mining in Bounded Treewidth Graphs}

Tree-width is a measure of how similar to a tree a graph is. It is a very useful property because several NP-hard problems on graphs become tractable for the class of graphs with bounded tree-width, including sub-graph isomorphism detection and, as a consequence, frequent sub-graph mining of connected graphs~\cite{Horvath}. \emph{Horvarth and Ramon} discovered a level-wise sub-graph mining algorithm that lists frequent connected sub-graphs in incremental polynomial time in cases when the tree-width of the graphs being mined is bounded by a constant~\cite{Horvath}. In addition, \emph{Thorup} shows that graphs representing the control flow of structured programs (\ie CFGs) have tree-width of at most six~\cite{Thorup}.  Since EFGs have the same topology as CFGs, they also have bounded tree-width. Thus, when applied to the PBPA problem, AFGMiner runs in incremental polynomial time because the problem being solved is fundamentally finding frequent connected sub-graphs in a dataset of EFGs. The addition of weights in nodes and edges and weighted attributes to nodes does not change the complexity of the algorithm, but the generation of attribute sets of increasing size when creating new candidate patterns could. However, the number of attributes that an extension node of a $k$-edge candidate pattern with $k > 0$, or that the single node of a 0-edge candidate pattern, can have is bounded by the size of $A$, \ie by the number of possible attributes that each pattern node may contain. As a consequence, the attribute-set growth component of the algorithm has a constant complexity, while the sub-graph mining component has incremental polynomial complexity.


