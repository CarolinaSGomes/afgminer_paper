This section discusses the patterns obtained by both HEPMiner and SCPMiner. Results were analyzed by expert developers from the IBM Canada Software Laboratory.
\subsection{HEPMiner Results}
The compiler engineer found HEPMiner to be a useful tool and was able to not only validade results according to previous knowledge about the benchmark, but also to make new observations about the run-time behavior of DayTrader when executed by the z196 hardware. The observations are summarized below.
\begin{enumerate}
\item AFGMiner found heavyweight patterns that contain an edge from a branch instruction leading to a node that has instruction cache misses as one of its attributes. Reviewing the occurrences of such patterns shows that this edge represents the taken path from the branch, which confirms the engineer's expectation that instruction cache misses should be observed only on the taken branch target.
\item From prior analysis, the expert at IBM knows that 30\% of overall CPU cycles in JITted code are assigned to method prologues, and 40\% of instruction cache misses are correlated with method prologues. This was confirmed in the results output by AFGMiner.
\item An attribute that represents a non-taken, correct-direction branch prediction was found to be dominant by AFGMiner. The fact that this attribute shows up highlights that the JIT compiler performs well when ordering basic blocks to optimize for fall-through paths. This discovery led to the creation of performance counters that take into account the ratio of taken and non-taken branches, and according to the IBM engineer was a very good confirmation to the compiler development team.
\item The output by AFGMiner shows patterns with low support value that have a certain attribute that is actually an instruction that is part of an asynchronous check sequence. This check sequence is used as a cooperative point in the method to allow for garbage collection and/or JIT compilation-related sampling mechanisms that determine which method is being executed. Such checks are placed at method entries and within hot loops. The expert at IBM confirmed that, given that DayTrader is a very flat benchmark, it is correct that the pattern should have such a low support.
\item Various patterns found by AFGMiner highlight switch-statements. Switch statements are not very common in the DayTrader code, but the JIT compiler does have an opportunity to convert between branch tables and if-statements when handling conditionals, or even to use a combination of both. The appearance of such patterns with relatively low support confirms the characteristics of DayTrader.
\item The relative support values for a sequence of three attributes, present in several patterns, were found to be relevant by the IBM developer. The attributes are an address-generation interlock, followed by a directory or data cache miss, and then an instruction used to load a compressed referenced field from an object. This discovery led to the implementation of the pattern in the compiler's instruction scheduler in order to reduce its negative effect on the run-time of future compiled applications.
\end{enumerate}
\subsection{SCPMiner Results}
A software engineer from the IBM Multi-core Performance Tooling team analyzed the patterns output by SCPMiner and the occurrences linked to each pattern. The main findings are as follows.

\begin{enumerate}
\item The top patterns of each one of the benchmarks had occurrences whose associated source-code lines were also indicated by the IBM tool. This indicates that SCPMiner is able to find the relevant patterns in an application.
\item However, many patterns uncovered by SCPMiner did not seem relevant to the IBM developer: he did not consider the pattern occurrences to be related to one another in any meaningful way, and therefore would not consider such occurrences to form a pattern if he were to analyze the programs himself. With that we concluded that the cluster analysis implemented in SCPMiner presents mixed results, not completely aligned with the perception that application developers have of what a pattern should be. Future development of SCPMiner should consider alternative clustering analysis in order to better align the results of the tool with the expectations of application developers.
\end{enumerate}
